//
// Generated by SwagGen
// https://github.com/pace/SwagGen
//

import Foundation

extension GeoJSONAPI {

    /**
    GeoJSON

    get a GeoJSON representation of POIs
    */
    public enum GetBetaGeojsonPois {

        public static var service = GeoJSONAPIService<Response>(id: "getBetaGeojsonPois", tag: "", method: "GET", path: "/geojson/pois", hasBody: false, securityRequirements: [])

        /** Only show POIs of the given type */
        public enum PCGeoJSONFilterpoiType: String, Codable, Equatable, CaseIterable {
            case gasStation = "GasStation"
            case speedCamera = "SpeedCamera"
        }

        public final class Request: GeoJSONAPIRequest<Response> {

            public struct Options {

                /** Comma separated list of fields. Selects additional fields to be returned. The requested fields will be shown in the `properties` attribute of each `GeoJsonFeature`.
Possible values are:
* type
* address
* stationName
* brand
* onlinePaymentMethods
* merchant
* dkvStationID
* hoyerID
 */
                public var fieldsgasStation: String?

                /** Only show POIs of the given type */
                public var filterpoiType: PCGeoJSONFilterpoiType?

                /** Filter results based on available online payment methods. Use a comma separated list to get stations for multiple payment method. */
                public var filteronlinePaymentMethod: String?

                /** Filter results based on merchant name. Value has to be the same as provided in the merchant field. */
                public var filtermerchant: String?

                /** Activate certain testing scenarios in the code */
                public var testing: String?

                /** Select a country to query. If this parameter is not provided data of all countries is returned. Country code in ISO 3166-1 alpha-2 format */
                public var filtercountry: String?

                /** If set, the request will only return POIs which have PACE Connected Fueling activated. 
To activate the filter, use one of the following values (all other values will result in the filter being ignored): 
* true
* yes
* y
* 1
* on
 */
                public var filterconnectedFueling: String?

                public init(fieldsgasStation: String? = nil, filterpoiType: PCGeoJSONFilterpoiType? = nil, filteronlinePaymentMethod: String? = nil, filtermerchant: String? = nil, testing: String? = nil, filtercountry: String? = nil, filterconnectedFueling: String? = nil) {
                    self.fieldsgasStation = fieldsgasStation
                    self.filterpoiType = filterpoiType
                    self.filteronlinePaymentMethod = filteronlinePaymentMethod
                    self.filtermerchant = filtermerchant
                    self.testing = testing
                    self.filtercountry = filtercountry
                    self.filterconnectedFueling = filterconnectedFueling
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: GetBetaGeojsonPois.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(fieldsgasStation: String? = nil, filterpoiType: PCGeoJSONFilterpoiType? = nil, filteronlinePaymentMethod: String? = nil, filtermerchant: String? = nil, testing: String? = nil, filtercountry: String? = nil, filterconnectedFueling: String? = nil) {
                let options = Options(fieldsgasStation: fieldsgasStation, filterpoiType: filterpoiType, filteronlinePaymentMethod: filteronlinePaymentMethod, filtermerchant: filtermerchant, testing: testing, filtercountry: filtercountry, filterconnectedFueling: filterconnectedFueling)
                self.init(options: options)
            }

            public override var queryParameters: [String: Any] {
                var params: [String: Any] = [:]
                if let fieldsgasStation = options.fieldsgasStation {
                  params["fields[gasStation]"] = fieldsgasStation
                }
                if let filterpoiType = options.filterpoiType?.encode() {
                  params["filter[poiType]"] = filterpoiType
                }
                if let filteronlinePaymentMethod = options.filteronlinePaymentMethod {
                  params["filter[onlinePaymentMethod]"] = filteronlinePaymentMethod
                }
                if let filtermerchant = options.filtermerchant {
                  params["filter[merchant]"] = filtermerchant
                }
                if let testing = options.testing {
                  params["testing"] = testing
                }
                if let filtercountry = options.filtercountry {
                  params["filter[country]"] = filtercountry
                }
                if let filterconnectedFueling = options.filterconnectedFueling {
                  params["filter[connectedFueling]"] = filterconnectedFueling
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {
            public typealias SuccessType = PCGeoJSONGeoJson

            /** OK */
            case status200(PCGeoJSONGeoJson)

            /** Error */
            case status400(String)

            public var success: PCGeoJSONGeoJson? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var failure: String? {
                switch self {
                case .status400(let response): return response
                default: return nil
                }
            }

            /// either success or failure value. Success is anything in the 200..<300 status code range
            public var responseResult: APIResponseResult<PCGeoJSONGeoJson, String> {
                if let successValue = success {
                    return .success(successValue)
                } else if let failureValue = failure {
                    return .failure(failureValue)
                } else {
                    fatalError("Response does not have success or failure response")
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .status400(let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .status400: return 400
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .status400: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(PCGeoJSONGeoJson.self, from: data))
                case 400: self = try .status400(decoder.decode(String.self, from: data))
                default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
