//
// Generated by SwagGen
// https://github.com/pace/SwagGen
//

import Foundation

public class PCSubscription: APIModel {

    public enum PCType: String, Codable, Equatable, CaseIterable {
        case subscription = "subscription"
    }

    public var attributes: Attributes?

    /** POI Subscription ID */
    public var id: ID?

    public var type: PCType?

    public class Attributes: APIModel {

        public var observedPois: [ID]

        /** PRN describing the push token. E.g. FCM token. */
        public var pushToken: String

        /** Optional conditions to reduce the number of notifications to the device. For a notification to be fired, all conditions need to be true.
    The example reads as `fuelPrice < 1.3 && fuelType == "diesel"`. For or conditions use multiple subscriptions.
     */
        public var conditions: Conditions?

        /** Time of subscription creation (iso8601 without time zone) */
        public var createdAt: DateTime?

        /** Time when the subscription will expire, must not be more then 60 days in the future (iso8601 without time zone) */
        public var expiresAt: DateTime?

        /** Time of LocationBasedApp last update (iso8601 without time zone) */
        public var updatedAt: DateTime?

        /** Optional conditions to reduce the number of notifications to the device. For a notification to be fired, all conditions need to be true.
        The example reads as `fuelPrice < 1.3 && fuelType == "diesel"`. For or conditions use multiple subscriptions.
         */
        public class Conditions: APIModel {

            /** Condition on the fuelPrice of a gas station. */
            public var fuelPrice: FuelPrice?

            /** Condition on the fuelType of a gas station */
            public var fuelType: FuelType?

            /** Condition on the fuelPrice of a gas station. */
            public class FuelPrice: APIModel {

                /** Fuel price is less then given amount. Amount is always given in the currency of the gas station. The units are not scaled, for `EUR`, the value 1.3 means 1 euro and 30 cents.
             */
                public var lt: Double?

                public init(lt: Double? = nil) {
                    self.lt = lt
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    lt = try container.decodeIfPresent("lt")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(lt, forKey: "lt")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? FuelPrice else { return false }
                  guard self.lt == object.lt else { return false }
                  return true
                }

                public static func == (lhs: FuelPrice, rhs: FuelPrice) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** Condition on the fuelType of a gas station */
            public class FuelType: APIModel {

                /** Fuel type is equal to given value */
                public enum PCEq: String, Codable, Equatable, CaseIterable {
                    case ron98 = "ron98"
                    case ron98e5 = "ron98e5"
                    case ron95e10 = "ron95e10"
                    case diesel = "diesel"
                    case e85 = "e85"
                    case ron91 = "ron91"
                    case ron95e5 = "ron95e5"
                    case ron100 = "ron100"
                    case dieselGtl = "dieselGtl"
                    case dieselB7 = "dieselB7"
                    case dieselB15 = "dieselB15"
                    case dieselPremium = "dieselPremium"
                    case lpg = "lpg"
                    case cng = "cng"
                    case lng = "lng"
                    case h2 = "h2"
                    case truckDiesel = "truckDiesel"
                    case adBlue = "adBlue"
                    case truckAdBlue = "truckAdBlue"
                    case truckDieselPremium = "truckDieselPremium"
                    case truckLpg = "truckLpg"
                    case heatingOil = "heatingOil"
                }

                /** Fuel type is equal to given value */
                public var eq: PCEq?

                public init(eq: PCEq? = nil) {
                    self.eq = eq
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    eq = try container.decodeIfPresent("eq")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(eq, forKey: "eq")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? FuelType else { return false }
                  guard self.eq == object.eq else { return false }
                  return true
                }

                public static func == (lhs: FuelType, rhs: FuelType) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public init(fuelPrice: FuelPrice? = nil, fuelType: FuelType? = nil) {
                self.fuelPrice = fuelPrice
                self.fuelType = fuelType
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                fuelPrice = try container.decodeIfPresent("fuelPrice")
                fuelType = try container.decodeIfPresent("fuelType")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(fuelPrice, forKey: "fuelPrice")
                try container.encodeIfPresent(fuelType, forKey: "fuelType")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Conditions else { return false }
              guard self.fuelPrice == object.fuelPrice else { return false }
              guard self.fuelType == object.fuelType else { return false }
              return true
            }

            public static func == (lhs: Conditions, rhs: Conditions) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(observedPois: [ID], pushToken: String, conditions: Conditions? = nil, createdAt: DateTime? = nil, expiresAt: DateTime? = nil, updatedAt: DateTime? = nil) {
            self.observedPois = observedPois
            self.pushToken = pushToken
            self.conditions = conditions
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.updatedAt = updatedAt
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            observedPois = try container.decodeArray("observedPois")
            pushToken = try container.decode("pushToken")
            conditions = try container.decodeIfPresent("conditions")
            createdAt = try container.decodeIfPresent("createdAt")
            expiresAt = try container.decodeIfPresent("expiresAt")
            updatedAt = try container.decodeIfPresent("updatedAt")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(observedPois, forKey: "observedPois")
            try container.encode(pushToken, forKey: "pushToken")
            try container.encodeIfPresent(conditions, forKey: "conditions")
            try container.encodeIfPresent(createdAt, forKey: "createdAt")
            try container.encodeIfPresent(expiresAt, forKey: "expiresAt")
            try container.encodeIfPresent(updatedAt, forKey: "updatedAt")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Attributes else { return false }
          guard self.observedPois == object.observedPois else { return false }
          guard self.pushToken == object.pushToken else { return false }
          guard self.conditions == object.conditions else { return false }
          guard self.createdAt == object.createdAt else { return false }
          guard self.expiresAt == object.expiresAt else { return false }
          guard self.updatedAt == object.updatedAt else { return false }
          return true
        }

        public static func == (lhs: Attributes, rhs: Attributes) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(attributes: Attributes? = nil, id: ID? = nil, type: PCType? = nil) {
        self.attributes = attributes
        self.id = id
        self.type = type
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        attributes = try container.decodeIfPresent("attributes")
        id = try container.decodeIfPresent("id")
        type = try container.decodeIfPresent("type")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(attributes, forKey: "attributes")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(type, forKey: "type")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? PCSubscription else { return false }
      guard self.attributes == object.attributes else { return false }
      guard self.id == object.id else { return false }
      guard self.type == object.type else { return false }
      return true
    }

    public static func == (lhs: PCSubscription, rhs: PCSubscription) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
