//
// Generated by SwagGen
// https://github.com/pace/SwagGen
//

import Foundation

public class PCPayTransaction: APIModel {

    public enum PCPayType: String, Codable, Equatable, CaseIterable {
        case transaction = "transaction"
    }

    public var attributes: Attributes?

    /** ID of the new transaction. */
    public var id: ID?

    public var links: PCPayTransactionLinks?

    public var type: PCPayType?

    public class Attributes: APIModel {

        public var vat: VAT?

        /** Initial creation date of the transaction (https://tools.ietf.org/html/rfc3339#section-5.6).
     */
        public var createdAt: DateTime?

        /** Currency as specified in ISO-4217. */
        public var currency: String?

        public var fuel: PCPayFuel?

        /** PACE resource name */
        public var issuerPRN: String?

        public var location: PCPayReadOnlyLocation?

        /** Current mileage in meters */
        public var mileage: Int?

        /** ID of the paymentMethod */
        public var paymentMethodId: ID?

        /** Payment Method Kind as name. */
        public var paymentMethodKind: String?

        /** Payment token value */
        public var paymentToken: String?

        public var priceIncludingVAT: Double?

        public var priceWithoutVAT: Double?

        /** PACE resource name - referring to the transaction purpose with provider details. */
        public var providerPRN: String?

        /** PACE resource name */
        public var purposePRN: String?

        public var references: [String]?

        /** Date of the last update (https://tools.ietf.org/html/rfc3339#section-5.6).
     */
        public var updatedAt: DateTime?

        /** Vehicle identification number */
        public var vin: String?

        public class VAT: APIModel {

            public var amount: Double?

            public var rate: Double?

            public init(amount: Double? = nil, rate: Double? = nil) {
                self.amount = amount
                self.rate = rate
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                amount = try container.decodeIfPresent("amount")
                rate = try container.decodeIfPresent("rate")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(amount, forKey: "amount")
                try container.encodeIfPresent(rate, forKey: "rate")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? VAT else { return false }
              guard self.amount == object.amount else { return false }
              guard self.rate == object.rate else { return false }
              return true
            }

            public static func == (lhs: VAT, rhs: VAT) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(vat: VAT? = nil, createdAt: DateTime? = nil, currency: String? = nil, fuel: PCPayFuel? = nil, issuerPRN: String? = nil, location: PCPayReadOnlyLocation? = nil, mileage: Int? = nil, paymentMethodId: ID? = nil, paymentMethodKind: String? = nil, paymentToken: String? = nil, priceIncludingVAT: Double? = nil, priceWithoutVAT: Double? = nil, providerPRN: String? = nil, purposePRN: String? = nil, references: [String]? = nil, updatedAt: DateTime? = nil, vin: String? = nil) {
            self.vat = vat
            self.createdAt = createdAt
            self.currency = currency
            self.fuel = fuel
            self.issuerPRN = issuerPRN
            self.location = location
            self.mileage = mileage
            self.paymentMethodId = paymentMethodId
            self.paymentMethodKind = paymentMethodKind
            self.paymentToken = paymentToken
            self.priceIncludingVAT = priceIncludingVAT
            self.priceWithoutVAT = priceWithoutVAT
            self.providerPRN = providerPRN
            self.purposePRN = purposePRN
            self.references = references
            self.updatedAt = updatedAt
            self.vin = vin
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            vat = try container.decodeIfPresent("VAT")
            createdAt = try container.decodeIfPresent("createdAt")
            currency = try container.decodeIfPresent("currency")
            fuel = try container.decodeIfPresent("fuel")
            issuerPRN = try container.decodeIfPresent("issuerPRN")
            location = try container.decodeIfPresent("location")
            mileage = try container.decodeIfPresent("mileage")
            paymentMethodId = try container.decodeIfPresent("paymentMethodId")
            paymentMethodKind = try container.decodeIfPresent("paymentMethodKind")
            paymentToken = try container.decodeIfPresent("paymentToken")
            priceIncludingVAT = try container.decodeIfPresent("priceIncludingVAT")
            priceWithoutVAT = try container.decodeIfPresent("priceWithoutVAT")
            providerPRN = try container.decodeIfPresent("providerPRN")
            purposePRN = try container.decodeIfPresent("purposePRN")
            references = try container.decodeArrayIfPresent("references")
            updatedAt = try container.decodeIfPresent("updatedAt")
            vin = try container.decodeIfPresent("vin")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(vat, forKey: "VAT")
            try container.encodeIfPresent(createdAt, forKey: "createdAt")
            try container.encodeIfPresent(currency, forKey: "currency")
            try container.encodeIfPresent(fuel, forKey: "fuel")
            try container.encodeIfPresent(issuerPRN, forKey: "issuerPRN")
            try container.encodeIfPresent(location, forKey: "location")
            try container.encodeIfPresent(mileage, forKey: "mileage")
            try container.encodeIfPresent(paymentMethodId, forKey: "paymentMethodId")
            try container.encodeIfPresent(paymentMethodKind, forKey: "paymentMethodKind")
            try container.encodeIfPresent(paymentToken, forKey: "paymentToken")
            try container.encodeIfPresent(priceIncludingVAT, forKey: "priceIncludingVAT")
            try container.encodeIfPresent(priceWithoutVAT, forKey: "priceWithoutVAT")
            try container.encodeIfPresent(providerPRN, forKey: "providerPRN")
            try container.encodeIfPresent(purposePRN, forKey: "purposePRN")
            try container.encodeIfPresent(references, forKey: "references")
            try container.encodeIfPresent(updatedAt, forKey: "updatedAt")
            try container.encodeIfPresent(vin, forKey: "vin")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Attributes else { return false }
          guard self.vat == object.vat else { return false }
          guard self.createdAt == object.createdAt else { return false }
          guard self.currency == object.currency else { return false }
          guard self.fuel == object.fuel else { return false }
          guard self.issuerPRN == object.issuerPRN else { return false }
          guard self.location == object.location else { return false }
          guard self.mileage == object.mileage else { return false }
          guard self.paymentMethodId == object.paymentMethodId else { return false }
          guard self.paymentMethodKind == object.paymentMethodKind else { return false }
          guard self.paymentToken == object.paymentToken else { return false }
          guard self.priceIncludingVAT == object.priceIncludingVAT else { return false }
          guard self.priceWithoutVAT == object.priceWithoutVAT else { return false }
          guard self.providerPRN == object.providerPRN else { return false }
          guard self.purposePRN == object.purposePRN else { return false }
          guard self.references == object.references else { return false }
          guard self.updatedAt == object.updatedAt else { return false }
          guard self.vin == object.vin else { return false }
          return true
        }

        public static func == (lhs: Attributes, rhs: Attributes) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(attributes: Attributes? = nil, id: ID? = nil, links: PCPayTransactionLinks? = nil, type: PCPayType? = nil) {
        self.attributes = attributes
        self.id = id
        self.links = links
        self.type = type
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        attributes = try container.decodeIfPresent("attributes")
        id = try container.decodeIfPresent("id")
        links = try container.decodeIfPresent("links")
        type = try container.decodeIfPresent("type")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(attributes, forKey: "attributes")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(links, forKey: "links")
        try container.encodeIfPresent(type, forKey: "type")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? PCPayTransaction else { return false }
      guard self.attributes == object.attributes else { return false }
      guard self.id == object.id else { return false }
      guard self.links == object.links else { return false }
      guard self.type == object.type else { return false }
      return true
    }

    public static func == (lhs: PCPayTransaction, rhs: PCPayTransaction) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
