//
// Generated by SwagGen
// https://github.com/pace/SwagGen
//

import Foundation

public class PCUserOAuth2TokenExchangeRequest: APIModel {

    /** The value of the parameter must be `urn:ietf:params:oauth:grant-type:token-exchange`.
     */
    public enum PCUserGrantType: String, Codable, Equatable, CaseIterable {
        case urnietfparamsoauthgrantTypetokenExchange = "urn:ietf:params:oauth:grant-type:token-exchange"
    }

    /** This parameter represents the type of token the client wants to exchange for.
    Currently only oauth and OpenID Connect token types are supported specifically `urn:ietf:params:oauth:token-type:access_token`.
     */
    public enum PCUserSubjectTokenType: String, Codable, Equatable, CaseIterable {
        case urnietfparamsoauthtokenTypeaccessToken = "urn:ietf:params:oauth:token-type:access_token"
    }

    /** This parameter is required for clients using form parameters for authentication.
 */
    public var clientId: String

    /** This parameter is required for clients using form parameters for authentication
and using a client secret as a credential.
 */
    public var clientSecret: String

    /** The value of the parameter must be `urn:ietf:params:oauth:grant-type:token-exchange`.
 */
    public var grantType: PCUserGrantType

    /** A security token that represents the identity of the party on behalf of whom the request is being made.
It is required if you are exchanging an existing token for a new one.
 */
    public var subjectToken: String

    /** Identifies the issuer of the subject_token. The same as the tokens `iss` value. Usually a URL.
 */
    public var subjectIssuer: String

    /** This parameter represents the type of token the client wants to exchange for.
Currently only oauth and OpenID Connect token types are supported specifically `urn:ietf:params:oauth:token-type:access_token`.
 */
    public var subjectTokenType: PCUserSubjectTokenType

    /** This parameter specifies the target client you want the new token minted for. This will be part
of the token in the `aud` field. If left blank it will be the same as the provided `client_id`.
 */
    public var audience: String?

    /** This parameter represents the target set of OAuth and OpenID Connect scopes the client is requesting.
This parameter ensures to the client that the token is only provided in case the requested scopes
are part of it. More scopes may be returned.
 */
    public var scope: String?

    public init(clientId: String, clientSecret: String, grantType: PCUserGrantType, subjectToken: String, subjectIssuer: String, subjectTokenType: PCUserSubjectTokenType, audience: String? = nil, scope: String? = nil) {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.grantType = grantType
        self.subjectToken = subjectToken
        self.subjectIssuer = subjectIssuer
        self.subjectTokenType = subjectTokenType
        self.audience = audience
        self.scope = scope
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        clientId = try container.decode("client_id")
        clientSecret = try container.decode("client_secret")
        grantType = try container.decode("grant_type")
        subjectToken = try container.decode("subject_token")
        subjectIssuer = try container.decode("subject_issuer")
        subjectTokenType = try container.decode("subject_token_type")
        audience = try container.decodeIfPresent("audience")
        scope = try container.decodeIfPresent("scope")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(clientId, forKey: "client_id")
        try container.encode(clientSecret, forKey: "client_secret")
        try container.encode(grantType, forKey: "grant_type")
        try container.encode(subjectToken, forKey: "subject_token")
        try container.encode(subjectIssuer, forKey: "subject_issuer")
        try container.encode(subjectTokenType, forKey: "subject_token_type")
        try container.encodeIfPresent(audience, forKey: "audience")
        try container.encodeIfPresent(scope, forKey: "scope")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? PCUserOAuth2TokenExchangeRequest else { return false }
      guard self.clientId == object.clientId else { return false }
      guard self.clientSecret == object.clientSecret else { return false }
      guard self.grantType == object.grantType else { return false }
      guard self.subjectToken == object.subjectToken else { return false }
      guard self.subjectIssuer == object.subjectIssuer else { return false }
      guard self.subjectTokenType == object.subjectTokenType else { return false }
      guard self.audience == object.audience else { return false }
      guard self.scope == object.scope else { return false }
      return true
    }

    public static func == (lhs: PCUserOAuth2TokenExchangeRequest, rhs: PCUserOAuth2TokenExchangeRequest) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
