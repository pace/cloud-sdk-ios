//
// Generated by SwagGen
// https://github.com/pace/SwagGen
//

import Foundation

public class PCPayPaymentTokenCreateGooglePayRequest: APIModel {

    public enum PCPayType: String, Codable, Equatable, CaseIterable {
        case paymentToken = "paymentToken"
    }

    public var type: PCPayType

    public var attributes: Attributes

    /** Unique ID of the new paymentToken. */
    public var id: ID?

    public class Attributes: APIModel {

        /** Currency as specified in ISO-4217. */
        public var currency: String

        public var amount: Decimal

        /** PACE resource name(s) of one or multiple resources, for which the payment should be authorized. */
        public var purposePRNs: [String]

        /** The encrypted data received from GooglePay */
        public var googlePay: GooglePay

        public var discountTokens: [String]?

        /** The code and method for two factor authentication, if required by the payment method */
        public var twoFactor: TwoFactor?

        /** The encrypted data received from GooglePay */
        public class GooglePay: APIModel {

            public var paymentData: PaymentData?

            public var signature: String?

            public var version: String?

            /** The encrypted data received from GooglePay */
            public class PaymentData: APIModel {

                public var encryptedMessage: String?

                public var ephemeralPublicKey: String?

                public var tag: String?

                public init(encryptedMessage: String? = nil, ephemeralPublicKey: String? = nil, tag: String? = nil) {
                    self.encryptedMessage = encryptedMessage
                    self.ephemeralPublicKey = ephemeralPublicKey
                    self.tag = tag
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    encryptedMessage = try container.decodeIfPresent("encryptedMessage")
                    ephemeralPublicKey = try container.decodeIfPresent("ephemeralPublicKey")
                    tag = try container.decodeIfPresent("tag")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(encryptedMessage, forKey: "encryptedMessage")
                    try container.encodeIfPresent(ephemeralPublicKey, forKey: "ephemeralPublicKey")
                    try container.encodeIfPresent(tag, forKey: "tag")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? PaymentData else { return false }
                  guard self.encryptedMessage == object.encryptedMessage else { return false }
                  guard self.ephemeralPublicKey == object.ephemeralPublicKey else { return false }
                  guard self.tag == object.tag else { return false }
                  return true
                }

                public static func == (lhs: PaymentData, rhs: PaymentData) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public init(paymentData: PaymentData? = nil, signature: String? = nil, version: String? = nil) {
                self.paymentData = paymentData
                self.signature = signature
                self.version = version
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                paymentData = try container.decodeIfPresent("paymentData")
                signature = try container.decodeIfPresent("signature")
                version = try container.decodeIfPresent("version")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(paymentData, forKey: "paymentData")
                try container.encodeIfPresent(signature, forKey: "signature")
                try container.encodeIfPresent(version, forKey: "version")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? GooglePay else { return false }
              guard self.paymentData == object.paymentData else { return false }
              guard self.signature == object.signature else { return false }
              guard self.version == object.version else { return false }
              return true
            }

            public static func == (lhs: GooglePay, rhs: GooglePay) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        /** The code and method for two factor authentication, if required by the payment method */
        public class TwoFactor: APIModel {

            /** A single name for the 2fa e.g. `face-id`, `fingerprint`, `biometry`, `password`, `pin` */
            public var method: String?

            /** OTP (One time password) for the authorization. */
            public var otp: String?

            public init(method: String? = nil, otp: String? = nil) {
                self.method = method
                self.otp = otp
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                method = try container.decodeIfPresent("method")
                otp = try container.decodeIfPresent("otp")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(method, forKey: "method")
                try container.encodeIfPresent(otp, forKey: "otp")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? TwoFactor else { return false }
              guard self.method == object.method else { return false }
              guard self.otp == object.otp else { return false }
              return true
            }

            public static func == (lhs: TwoFactor, rhs: TwoFactor) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(currency: String, amount: Decimal, purposePRNs: [String], googlePay: GooglePay, discountTokens: [String]? = nil, twoFactor: TwoFactor? = nil) {
            self.currency = currency
            self.amount = amount
            self.purposePRNs = purposePRNs
            self.googlePay = googlePay
            self.discountTokens = discountTokens
            self.twoFactor = twoFactor
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            currency = try container.decode("currency")
            amount = try container.decode("amount")
            purposePRNs = try container.decodeArray("purposePRNs")
            googlePay = try container.decode("googlePay")
            discountTokens = try container.decodeArrayIfPresent("discountTokens")
            twoFactor = try container.decodeIfPresent("twoFactor")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encode(currency, forKey: "currency")
            try container.encode(amount, forKey: "amount")
            try container.encode(purposePRNs, forKey: "purposePRNs")
            try container.encode(googlePay, forKey: "googlePay")
            try container.encodeIfPresent(discountTokens, forKey: "discountTokens")
            try container.encodeIfPresent(twoFactor, forKey: "twoFactor")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Attributes else { return false }
          guard self.currency == object.currency else { return false }
          guard self.amount == object.amount else { return false }
          guard self.purposePRNs == object.purposePRNs else { return false }
          guard self.googlePay == object.googlePay else { return false }
          guard self.discountTokens == object.discountTokens else { return false }
          guard self.twoFactor == object.twoFactor else { return false }
          return true
        }

        public static func == (lhs: Attributes, rhs: Attributes) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(type: PCPayType, attributes: Attributes, id: ID? = nil) {
        self.type = type
        self.attributes = attributes
        self.id = id
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        type = try container.decode("type")
        attributes = try container.decode("attributes")
        id = try container.decodeIfPresent("id")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(type, forKey: "type")
        try container.encode(attributes, forKey: "attributes")
        try container.encodeIfPresent(id, forKey: "id")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? PCPayPaymentTokenCreateGooglePayRequest else { return false }
      guard self.type == object.type else { return false }
      guard self.attributes == object.attributes else { return false }
      guard self.id == object.id else { return false }
      return true
    }

    public static func == (lhs: PCPayPaymentTokenCreateGooglePayRequest, rhs: PCPayPaymentTokenCreateGooglePayRequest) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
