//
// Generated by SwagGen
// https://github.com/pace/SwagGen
//

import Foundation

public class PCPayTransactionLinks: APIModel {

    public var receipt: Receipt?

    public var receiptPDF: ReceiptPDF?

    public class Receipt: APIModel {

        public var href: String?

        public var meta: Meta?

        public class Meta: APIModel {

            public enum PCPayMimeType: String, Codable, Equatable, CaseIterable {
                case imagepng = "image/png"
            }

            public var mimeType: PCPayMimeType?

            public init(mimeType: PCPayMimeType? = nil) {
                self.mimeType = mimeType
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                mimeType = try container.decodeIfPresent("mimeType")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(mimeType, forKey: "mimeType")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Meta else { return false }
              guard self.mimeType == object.mimeType else { return false }
              return true
            }

            public static func == (lhs: Meta, rhs: Meta) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(href: String? = nil, meta: Meta? = nil) {
            self.href = href
            self.meta = meta
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            href = try container.decodeIfPresent("href")
            meta = try container.decodeIfPresent("meta")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(href, forKey: "href")
            try container.encodeIfPresent(meta, forKey: "meta")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? Receipt else { return false }
          guard self.href == object.href else { return false }
          guard self.meta == object.meta else { return false }
          return true
        }

        public static func == (lhs: Receipt, rhs: Receipt) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public class ReceiptPDF: APIModel {

        public var href: String?

        public var meta: Meta?

        public class Meta: APIModel {

            public enum PCPayMimeType: String, Codable, Equatable, CaseIterable {
                case applicationpdf = "application/pdf"
            }

            public var mimeType: PCPayMimeType?

            public init(mimeType: PCPayMimeType? = nil) {
                self.mimeType = mimeType
            }

            public required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: StringCodingKey.self)

                mimeType = try container.decodeIfPresent("mimeType")
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: StringCodingKey.self)

                try container.encodeIfPresent(mimeType, forKey: "mimeType")
            }

            public func isEqual(to object: Any?) -> Bool {
              guard let object = object as? Meta else { return false }
              guard self.mimeType == object.mimeType else { return false }
              return true
            }

            public static func == (lhs: Meta, rhs: Meta) -> Bool {
                return lhs.isEqual(to: rhs)
            }
        }

        public init(href: String? = nil, meta: Meta? = nil) {
            self.href = href
            self.meta = meta
        }

        public required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: StringCodingKey.self)

            href = try container.decodeIfPresent("href")
            meta = try container.decodeIfPresent("meta")
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: StringCodingKey.self)

            try container.encodeIfPresent(href, forKey: "href")
            try container.encodeIfPresent(meta, forKey: "meta")
        }

        public func isEqual(to object: Any?) -> Bool {
          guard let object = object as? ReceiptPDF else { return false }
          guard self.href == object.href else { return false }
          guard self.meta == object.meta else { return false }
          return true
        }

        public static func == (lhs: ReceiptPDF, rhs: ReceiptPDF) -> Bool {
            return lhs.isEqual(to: rhs)
        }
    }

    public init(receipt: Receipt? = nil, receiptPDF: ReceiptPDF? = nil) {
        self.receipt = receipt
        self.receiptPDF = receiptPDF
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        receipt = try container.decodeIfPresent("receipt")
        receiptPDF = try container.decodeIfPresent("receiptPDF")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(receipt, forKey: "receipt")
        try container.encodeIfPresent(receiptPDF, forKey: "receiptPDF")
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? PCPayTransactionLinks else { return false }
      guard self.receipt == object.receipt else { return false }
      guard self.receiptPDF == object.receiptPDF else { return false }
      return true
    }

    public static func == (lhs: PCPayTransactionLinks, rhs: PCPayTransactionLinks) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
